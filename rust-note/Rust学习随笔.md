# Rust学习笔记

## 指针、引用、智能指针

### 指针

Rust提供了多种类型的指针：

1. 引用（Reference），共享引用&，可变引用&mut
2. 原生指针,又叫裸指针（Raw Pointer），*const和*mut
3. 智能指针（Smart Pointer），Box，Rc等

### 引用

1. 共享数据，但不获得其所有权，即变量的所有者仍然只有一个
2. 在作用域中的数据有且只能有一个可变引用
3. 可以有多个不可变引用
4. 不能同时拥有不可变引用和可变引用

注意，以下表示等价关系。

1. ref在等于号左边等价于&符号在等号右边
```Rust
let ref x = 1;
let x = &1;
```
2. &在等于号左边等价于*号在等于号右边
```Rust
let &y = x;
let y = *x;
```
### 智能指针

在Rust中，引用和智能指针的一个的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。Rust标准库中不同的智能指针提供了比引用更丰富的功能：

1. Box，用于在堆上分配数据，只能有一个所有者
2. Rc，一个引用计数类型，其数据可以有多个所有者。
3. Ref 和 RefMut，通过RefCell访问，一个在运行时而不是在编译时执行借用规则的类型。




## 生命周期

生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据

在编译期，Rust 会比较两个变量的生命周期，结果发现变量r明明拥有生命周期 'a，但是却引用了一个小得多的生命周期'b，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。

**保证引用的变量的生命周期小于等于自身！**

当存在**多个引用时**，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

### 生命周期标注语法

#### 函数中的生命周期
```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

该函数签名表明对于某些生命周期 'a，函数的两个参数都至少跟 'a 活得一样久，同时函数的返回引用也至少跟 'a 活得一样久。

在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过。

因此 longest 函数并不知道 x 和 y 具体会活多久，只要知道它们的作用域至少能持续 'a 这么长。

当把具体的引用传给 longest 时，那生命周期 'a 的大小就是 x 和 y 的作用域的重合部分，换句话说，'a 的大小将等于 x 和 y 中较小的那个。由于返回值的生命周期也被标记为 'a，因此返回值的生命周期也是 x 和 y 中作用域较小的那个。

#### 结构体中的生命周期

```Rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

ImportantExcerpt 结构体中有一个引用类型的字段 part，因此需要为它标注上生命周期。该生命周期标注说明，结构体 ImportantExcerpt 所引用的字符串 str 必须比该结构体活得更久。

从 main 函数实现来看，ImportantExcerpt 的生命周期从第 4 行开始，到 main 函数末尾结束，而该结构体引用的字符串从第一行开始，也是到 main 函数末尾结束，可以得出结论结构体引用的字符串活得比结构体久，这符合了编译器对生命周期的要求，因此编译通过。

### 生命周期消除

1. 每一个引用参数都会获得独自的生命周期

例如一个引用参数的函数就有一个生命周期标注: fn foo<'a>(x: &'a i32)，两个引用参数的有两个生命周期标注:fn foo<'a, 'b>(x: &'a i32, y: &'b i32), 依此类推。

2. 若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期

例如函数 fn foo(x: &i32) -> &i32，x 参数的生命周期会被自动赋给返回值 &i32，因此该函数等同于 fn foo<'a>(x: &'a i32) -> &'a i32

3. 若存在多个输入生命周期，且其中一个是 &self 或 &mut self，则 &self 的生命周期被赋给所有的输出生命周期

### 方法中的生命周期

```Rust
impl<'a: 'b, 'b> ImportantExcerpt<'a> {
    fn announce_and_return_part(&'a self, announcement: &'b str) -> &'b str {...
    }
}
```
'a: 'b，是生命周期约束语法，用于说明 'a 生命周期大于 'b

```Rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part<'b>(&'a self, announcement: &'b str) -> &'b str
    where
        'a: 'b,
    {...}
}
```